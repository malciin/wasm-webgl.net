<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".js" #>
<#

var content = File.ReadAllText(Host.ResolvePath("webgl.spec.xml"));
using var memStream = new MemoryStream(Encoding.UTF8.GetBytes(content));
var xmlDocument = XDocument.Load(memStream);
var methods = xmlDocument.Root.Element("methods").Descendants("method");

#>
/// Generated by webgl-bindings.tt at <#= DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss") + " UTC" #>
/// Bindings are generated based on specification from webgl.spec.xml

let context = null;
let webGlDataIndex = -1;
// not sure is it safe to send JS objects like WebGLBuffer back to .NET so
// for now those objects are stored in webGlData and .NET receive only a proper index to that lookup. This kinda works simmilarly to openGL.
const webGlData = {};
const uniformLocationsToWebGlDataIndex = {};

<#
foreach (var method in methods)
{
	var methodName = method.Attribute("name").Value;
    var defaultCode = "context."
        + methodName.Substring(2, 1).ToLowerInvariant()
        + methodName.Substring(3)
        + "("
        + string.Join(", ", method.Descendants("param").Select(x => x.Attribute("name").Value))
        + ");";
    var jsCode = method.Descendants("jsCode").FirstOrDefault()?.Value;

    if (jsCode != null)
    {
        jsCode = Regex.Replace(jsCode, @"\s+", " ").Trim();
    }
#>
export const <#= methodName #> = (<#=
    string.Join(", ", method.Descendants("param").Select(x => x.Attribute("name").Value)) #>) => { <#=
    jsCode ?? defaultCode #> };
<# } #>
